# DuckChat 服务器实现

本文档描述了 DuckChat 服务器的具体实现逻辑和代码结构，基于实际的代码实现。

## 核心架构

### 主要组件
- **主服务器** ([`server.cpp`](../server/server.cpp)): 监听客户端连接，创建会话
- **会话管理器** ([`session_manager.hpp`](../server/session_manager.hpp)): 管理所有客户端会话
- **会话类** ([`session.hpp`](../server/session.hpp)): 处理单个客户端的请求
- **数据库管理器** ([`database.hpp`](../server/database.hpp)): 处理所有数据库操作
- **通信协议** ([`common/protocal.hpp`](../common/protocal.hpp)): 定义数据包格式
- **网络通信** ([`common/network.hpp`](../common/network.hpp)): 处理网络传输

### 线程模型
```
主线程 (监听连接)
├── 会话线程1 (处理客户端1)
├── 会话线程2 (处理客户端2)
├── 会话线程3 (处理客户端3)
└── ...
```

每个客户端连接都会创建一个独立的线程来处理该客户端的所有请求。

## 核心类设计

### 主服务器 (server.cpp)
```cpp
int main() {
    signal(SIGPIPE, SIG_IGN);  // 忽略SIGPIPE信号
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    
    sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(5001);  // 监听5001端口
    
    bind(server_fd, (sockaddr *)&address, sizeof(address));
    listen(server_fd, 10);
    
    while (true) {
        int client_sock = accept(server_fd, (sockaddr *)&address, (socklen_t *)&addrlen);
        session_manager.create_and_start_session(client_sock);
    }
}
```

### SessionManager 类
```cpp
class SessionManager {
private:
    Database database;                                         // 数据库实例
    std::mutex sessions_mutex;                                 // 会话列表互斥锁
    std::unordered_map<int, std::unique_ptr<Session>> sessions; // 会话列表

public:
    SessionManager();
    void create_and_start_session(int socket);
    void close_session(int socket);
    Database* get_database();
    int get_socket_by_user_id(const std::string& user_id);
};
```

**关键方法实现:**
- [`create_and_start_session()`](../server/session_manager.cpp:11): 创建新会话并启动处理线程
- [`get_database()`](../server/session_manager.cpp:35): 返回数据库实例指针
- [`get_socket_by_user_id()`](../server/session_manager.cpp:40): 根据用户ID查找对应的socket
- [`close_session()`](../server/session_manager.cpp:22): 关闭指定会话并清理资源

### Session 类
```cpp
class Session {
private:
    int socket;                    // 客户端socket
    SessionManager* session_manager; // 会话管理器指针

public:
    std::string username;          // 用户名
    std::string user_id;           // 用户ID
    
    Session(int socket, SessionManager* session_manager);
    void handle_session();
    ServerStatus handle_login(const ClientPacket& packet);
    ServerStatus handle_register(const ClientPacket& packet);
    void handle_message(const ClientPacket& packet);
    ServerStatus handle_new_chat(const ClientPacket& packet, const string& uuid);
    ServerStatus handle_join_chat(const ClientPacket& packet);
    ServerStatus handle_recall_message(const ClientPacket& packet);
    ServerStatus handle_leave_chat(const ClientPacket& packet);
};
```

**核心处理逻辑:**
- [`handle_session()`](../server/session.cpp:9): 主会话处理循环
- [`handle_login()`](../server/session.cpp:152): 处理用户登录
- [`handle_register()`](../server/session.cpp:169): 处理用户注册
- [`handle_message()`](../server/session.cpp:184): 处理消息发送和广播
- [`handle_new_chat()`](../server/session.cpp:214): 处理创建聊天室
- [`handle_join_chat()`](../server/session.cpp:225): 处理加入聊天室
- [`handle_recall_message()`](../server/session.cpp:235): 处理消息撤回
- [`handle_leave_chat()`](../server/session.cpp:250): 处理离开聊天室

## 协议处理逻辑

### 客户端协议定义 ([`common/protocal.hpp`](../common/protocal.hpp))

#### ClientMessage 枚举
```cpp
enum class ClientMessage {
    REGISTER,        // 用户注册
    LOGIN,           // 用户登录
    MESSAGE,         // 发送消息
    RECALL,          // 撤回消息
    LIST_CHATS,      // 获取聊天列表
    FETCH_MESSAGES,  // 获取历史消息
    CREATE_CHAT,     // 创建聊天室
    JOIN_CHAT,       // 加入聊天室
    LEAVE_CHAT,      // 离开聊天室
    LOGOUT,          // 用户登出
};
```

#### ClientPacket 结构
```cpp
struct ClientPacket {
    ClientMessage request;
    std::string username;        // 用户名（注册时使用）
    std::string password_hash;   // 密码哈希（登录时使用）
    std::string user_id;          // 用户ID
    std::string chat_id;          // 聊天室ID
    std::string chatname;         // 聊天室名称
    std::string message_id;       // 消息ID
    std::string message;          // 消息内容
};
```

### 服务器协议定义

#### ServerMessage 枚举
```cpp
enum class ServerMessage {
    REGISTER_RESPONSE,   // 注册响应
    LOGIN_RESPONSE,      // 登录响应
    CREATE_CHAT_RESPONSE,// 创建聊天室响应
    JOIN_CHAT_RESPONSE,  // 加入聊天室响应
    RETURN_CHATS,        // 返回聊天列表
    RETURN_MESSAGES      // 返回消息列表
};
```

#### ServerStatus 枚举
```cpp
enum class ServerStatus {
    SUCCESS,           // 操作成功
    USER_NOT_FOUND,    // 用户不存在
    INVALID_PASSWORD,  // 密码错误
    USER_EXISTS,       // 用户已存在
    CHAT_NOT_FOUND,    // 聊天室不存在
    CHAT_EXISTS,       // 聊天室已存在
};
```

### 会话处理流程

#### 主处理循环 ([`session.cpp:9-149`](../server/session.cpp:9))
```cpp
void Session::handle_session() {
    while (true) {
        if (!check_online(socket)) {
            session_manager->close_session(socket);
            break;
        }
        ClientPacket received_packet = recv_client_packet(socket);
        
        switch (received_packet.request) {
        case ClientMessage::LOGIN:
            // 处理登录请求
            ServerStatus status = handle_login(received_packet);
            ServerPacket packet;
            packet.request = ServerMessage::LOGIN_RESPONSE;
            packet.status = status;
            if (status != ServerStatus::SUCCESS) {
                log(LogLevel::ERROR, "user_id: " + received_packet.user_id + " login failed!");
            } else {
                packet.username = username;
                packet.user_id = user_id;
                log(LogLevel::INFO, "user_id: " + user_id + " login success!");
            }
            send_packet(socket, packet);
            break;
            
        case ClientMessage::REGISTER:
            // 处理注册请求
            ServerStatus status = handle_register(received_packet);
            ServerPacket packet;
            packet.username = username;
            packet.user_id = user_id;
            packet.request = ServerMessage::REGISTER_RESPONSE;
            packet.status = status;
            send_packet(socket, packet);
            break;
            
        case ClientMessage::MESSAGE:
            // 处理消息发送和广播
            handle_message(received_packet);
            log(LogLevel::INFO, user_id + ": " + received_packet.message);
            break;
            
        case ClientMessage::RECALL:
            // 处理消息撤回
            ServerStatus status = handle_recall_message(received_packet);
            ServerPacket packet;
            packet.request = ServerMessage::NEW_MESSAGE;
            packet.status = status;
            send_packet(socket, packet);
            break;
            
        case ClientMessage::LEAVE_CHAT:
            // 处理离开聊天室
            ServerStatus status = handle_leave_chat(received_packet);
            ServerPacket packet;
            packet.request = ServerMessage::JOIN_CHAT_RESPONSE;
            packet.status = status;
            packet.chat_id = received_packet.chat_id;
            send_packet(socket, packet);
            break;
            
        case ClientMessage::CREATE_CHAT:
            // 处理创建聊天室
            string uuid = Utils::get_uuid();
            ServerStatus status = handle_new_chat(received_packet, uuid);
            ServerPacket packet;
            packet.request = ServerMessage::CREATE_CHAT_RESPONSE;
            packet.status = status;
            packet.chat_id = uuid;
            packet.chatname = received_packet.chatname;
            packet.user_id = user_id;
            packet.username = username;
            ChatInfo info;
            info.chat_id = uuid;
            info.chatname = received_packet.chatname;
            info.role = "member";
            packet.chats.push_back(info);
            send_packet(socket, packet);
            break;
            
        case ClientMessage::JOIN_CHAT:
            // 处理加入聊天室
            ServerStatus status = handle_join_chat(received_packet);
            ServerPacket packet;
            packet.request = ServerMessage::JOIN_CHAT_RESPONSE;
            packet.status = status;
            packet.chat_id = received_packet.chat_id;
            packet.chatname = session_manager->get_database()->get_chatname(received_packet.chat_id);
            packet.user_id = user_id;
            packet.username = username;
            ChatInfo info;
            info.chat_id = received_packet.chat_id;
            info.chatname = received_packet.chatname;
            info.role = "member";
            packet.chats.push_back(info);
            send_packet(socket, packet);
            break;
            
        case ClientMessage::LIST_CHATS:
            // 处理获取聊天列表
            ServerPacket packet;
            packet.request = ServerMessage::RETURN_CHATS;
            packet.status = ServerStatus::SUCCESS;
            packet.user_id = user_id;
            packet.username = username;
            packet.chats = session_manager->get_database()->list_user_chats(received_packet.user_id);
            send_packet(socket, packet);
            break;
            
        case ClientMessage::FETCH_MESSAGES:
            // 处理获取消息历史
            ServerPacket packet;
            packet.request = ServerMessage::RETURN_MESSAGES;
            packet.status = ServerStatus::SUCCESS;
            packet.user_id = user_id;
            packet.username = username;
            packet.message_list = session_manager->get_database()->fetch_chat_messages(received_packet.chat_id);
            send_packet(socket, packet);
            break;
            
        default:
            break;
        }
    }
}
```

#### 登录处理 ([`session.cpp:52-67`](../server/session.cpp:52))
```cpp
ServerStatus Session::handle_login(const ClientPacket& packet, Session& session) {
    Database* db = session_manager->get_database();
    
    // 检查用户是否存在
    if (!db->exist_user(packet.user_id))
        return ServerStatus::USER_NOT_FOUND;
    
    // 验证密码
    if (packet.password_hash == db->get_password_hash(packet.user_id)) {
        session.user_id = packet.user_id;
        session.username = db->get_username(packet.user_id);
        return ServerStatus::SUCCESS;
    } else {
        return ServerStatus::INVALID_PASSWORD;
    }
}
```

#### 注册处理 ([`session.cpp:69-82`](../server/session.cpp:69))
```cpp
ServerStatus Session::handle_register(const ClientPacket& packet, Session& session) {
    Database* db = session_manager->get_database();
    
    // 检查用户是否已存在
    if (db->exist_user(packet.user_id))
        return ServerStatus::USER_EXISTS;
    else {
        // 创建新用户
        db->add_user(packet.user_id, packet.username, packet.password_hash);
        session.user_id = packet.user_id;
        session.username = packet.username;
        return ServerStatus::SUCCESS;
    }
}
```

## 数据库实现

### Database 类结构 ([`database.hpp`](../server/database.hpp))

#### 数据结构定义
```cpp
struct ChatInfo {
    std::string chat_id;
    std::string chatname;
    std::string creator_user_id;
    std::vector<std::string> members; 
};

struct Message {
    std::string message_id;
    std::string user_id;
    std::string content;
    std::string timestamp;
};
```

#### 核心方法
- [`exist_user()`](../server/database.cpp:62): 检查用户是否存在
- [`add_user()`](../server/database.cpp:80): 添加新用户
- [`get_username()`](../server/database.cpp:99): 获取用户名
- [`get_password_hash()`](../server/database.cpp:119): 获取密码哈希
- [`add_message()`](../server/database.cpp:139): 添加消息到数据库
- [`delete_message()`](../server/database.cpp:160): 删除消息（撤回功能）
- [`chat_exist()`](../server/database.cpp:174): 检查聊天室是否存在
- [`get_chatname()`](../server/database.cpp:192): 获取聊天室名称
- [`list_user_chats()`](../server/database.cpp:212): 获取用户参与的聊天列表
- [`fetch_chat_messages()`](../server/database.cpp:236): 获取聊天室消息历史
- [`add_chat()`](../server/database.cpp:265): 创建新聊天室
- [`get_chat_members()`](../server/database.cpp:284): 获取聊天室成员列表
- [`add_chat_member()`](../server/database.cpp:304): 添加聊天室成员
- [`leave_chat()`](../server/database.cpp:323): 用户离开聊天室

### 数据库初始化 ([`database.cpp:19-53`](../server/database.cpp:19))

#### 表结构
```sql
-- 用户表
CREATE TABLE IF NOT EXISTS users (
    user_id TEXT PRIMARY KEY,
    username TEXT NOT NULL,
    password_hash TEXT NOT NULL
);

-- 聊天室表
CREATE TABLE IF NOT EXISTS chats (
    chat_id TEXT PRIMARY KEY,
    chatname TEXT NOT NULL,
    creator_id TEXT NOT NULL,
    FOREIGN KEY (creator_id) REFERENCES users(user_id)
);

-- 聊天室成员表
CREATE TABLE IF NOT EXISTS chat_members (
    chat_id TEXT,
    user_id TEXT NOT NULL,
    role TEXT DEFAULT 'member',
    FOREIGN KEY (chat_id) REFERENCES chats(chat_id),
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    UNIQUE(chat_id, user_id)
);

-- 消息表
CREATE TABLE IF NOT EXISTS messages (
    message_id TEXT PRIMARY KEY,
    chat_id TEXT NOT NULL,
    sender_id TEXT NOT NULL,
    content TEXT NOT NULL,
    sent_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chat_id) REFERENCES chats(chat_id),
    FOREIGN KEY (sender_id) REFERENCES users(user_id)
);
```

## 网络通信

### 数据包传输 ([`common/network.hpp`](../common/network.hpp))

#### 发送函数
```cpp
void send_packet(int socket, const ClientPacket& client_packet);
void send_packet(int socket, const ServerPacket& server_packet);
```

#### 接收函数
```cpp
ClientPacket recv_client_packet(int socket);
ServerPacket recv_server_packet(int socket);
```

### JSON序列化

使用 nlohmann/json 库进行数据包的序列化和反序列化：

```cpp
// ClientPacket 序列化
NLOHMANN_DEFINE_TYPE_INTRUSIVE(
    ClientPacket, request,
    username, password_hash, user_id,
    chat_id, chatname, message_id, message)

// ServerPacket 序列化
NLOHMANN_DEFINE_TYPE_INTRUSIVE(
    ServerPacket, request, status,
    user_id, username, chat_id,
    chatname, message_list)
```

## 日志系统

使用 [`common/log_helper.hpp`](../common/log_helper.hpp) 进行日志记录：

```cpp
// 日志级别
enum class LogLevel {
    DEBUG,
    INFO,
    WARNING,
    ERROR
};

// 日志记录
log(LogLevel::INFO, "Client Address: " + string(client_ip) + ":" + to_string(client_port));
log(LogLevel::ERROR, "Login Failed!");
log(LogLevel::INFO, user_id + ": " + packet.message);
```

## 当前实现状态

### 已实现功能
- ✅ 服务器启动和监听
- ✅ 客户端连接处理
- ✅ 用户注册功能
- ✅ 用户登录功能
- ✅ 完整的数据库操作
- ✅ 协议定义和数据包传输
- ✅ 基本日志记录
- ✅ 消息发送和广播
- ✅ 消息撤回功能
- ✅ 聊天室管理（创建、加入、离开）
- ✅ 消息历史获取
- ✅ 聊天列表获取
- ✅ 会话清理和错误处理
- ✅ 连接状态检测

### 待实现功能
- ⏳ 心跳机制
- ⏳ 消息加密功能
- ⏳ 文件传输支持
- ⏳ 在线用户状态显示

### 代码问题和建议

1. **会话管理**: [`close_session()`](../server/session_manager.cpp:22) 已实现会话关闭和资源清理
2. **消息处理**: [`handle_message()`](../server/session.cpp:184) 已实现完整的消息转发逻辑
3. **错误处理**: 已实现基本的异常处理和连接状态管理
4. **数据库方法**: [`database.hpp`](../server/database.hpp) 中声明的所有方法在 [`database.cpp`](../server/database.cpp) 中已完全实现
5. **协议一致性**: 服务器响应协议已完善，支持所有必要的消息类型

## 性能和安全考虑

### 性能优化
- 每个客户端独立线程，避免阻塞
- 使用互斥锁保护共享资源
- 数据库连接复用

### 安全措施
- 密码哈希存储（需要实现加盐）
- 输入验证和SQL注入防护
- 连接状态验证

## 扩展建议

1. **连接池**: 实现数据库连接池管理
2. **消息队列**: 使用消息队列处理高并发
3. **缓存机制**: 添加Redis缓存热点数据
4. **负载均衡**: 支持多服务器部署
5. **监控指标**: 添加性能监控和统计