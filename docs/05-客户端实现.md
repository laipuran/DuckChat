# DuckChat 客户端实现

本文档描述了 DuckChat 客户端的具体实现逻辑和代码结构，基于实际的代码实现。

## 核心架构

### 主要组件
- **主客户端** ([`client.cpp`](../client/client.cpp)): 程序入口和主循环
- **窗口管理器** ([`window_manager.hpp`](../client/window_manager.hpp)): 管理用户界面和窗口显示
- **聊天管理器** ([`chat_manager.hpp`](../client/chat_manager.hpp)): 处理聊天逻辑和网络通信
- **通信协议** ([`common/protocal.hpp`](../common/protocal.hpp)): 定义数据包格式
- **网络通信** ([`common/network.hpp`](../common/network.hpp)): 处理网络传输

### 线程模型
```
主线程 (UI渲染和输入处理)
├── 网络线程 (消息收发)
├── 消息处理线程 (协议解析)
└── UI更新线程 (界面刷新)
```

## 核心类设计

### 主客户端 (client.cpp)
```cpp
int main() {
    // 初始化网络连接
    // 创建窗口管理器
    // 创建聊天管理器
    // 启动UI主循环
    return 0;
}
```

### WindowManager 类
```cpp
class WindowManager {
private:
    // ncurses 窗口句柄
    WINDOW* main_window;
    WINDOW* chat_window;
    WINDOW* input_window;
    WINDOW* status_window;
    
    // 窗口尺寸
    int main_height, main_width;
    int chat_height, chat_width;
    int input_height, input_width;
    
    // UI状态
    bool running;
    int current_chat_index;
    
public:
    WindowManager();
    ~WindowManager();
    
    // 窗口管理
    void initialize_windows();
    void resize_windows();
    void refresh_windows();
    
    // 显示功能
    void display_chat_list(const std::vector<ChatInfo>& chats);
    void display_messages(const std::vector<Message>& messages);
    void display_status(const std::string& status);
    
    // 输入处理
    std::string get_user_input();
    void handle_key_input(int key);
    
    // UI控制
    void set_current_chat(int index);
    void show_notification(const std::string& message);
};
```

### ChatManager 类
```cpp
class ChatManager {
private:
    int server_sock;
    Chat current_chat;
    std::vector<ChatInfo> chat_list;
    std::string current_chat_id;
    WindowManager *window_manager;
    std::string current_user_id;
    std::string current_username;

public:
    ChatManager(int server_sock, WindowManager *window_manager, std::string user_id, std::string username);
    ChatManager() {};
    
    // 初始化和数据获取
    void initiate();
    
    // 服务器响应处理
    void handle_chat_lists(const ServerPacket &packet);
    void handle_chat_history(const ServerPacket &packet);
    void handle_new_message(const ServerPacket &packet);
    void handle_new_chat(const ServerPacket &packet);
    void handle_recall_message(const ServerPacket &packet);
    
    // 聊天操作
    void create_chat(const std::string &chatname);
    void join_chat(const std::string &chat_id);
    void leave_chat(const std::string &chat_id);
    void add_message(const std::string &message);
    void recall_message(const std::string &message_id);
};
```

## 用户界面设计

### 窗口布局
```
┌─────────────────────────────────────────────────────────────┐
│ DuckChat - 用户名                    [状态] [时间]          │ 标题栏
├─────────────┬───────────────────────────────────────────────┤
│ 聊天列表     │ 聊天消息区域                                  │
│ ✓ 聊天室1    │ [用户1] 12:30: Hello World!                  │
│ ✓ 聊天室2    │ [用户2] 12:31: Hi there!                     │
│   聊天室3    │ [用户1] 12:32: How are you?                  │
│   聊天室4    │                                               │
│   聊天室5    │                                               │
│             │                                               │
├─────────────┴───────────────────────────────────────────────┤
│ > 输入消息内容...                                          │ 输入栏
└─────────────────────────────────────────────────────────────┘
```

### 窗口功能
1. **标题栏**: 显示应用名称、当前用户、连接状态和时间
2. **聊天列表**: 显示用户参与的所有聊天室，支持选择切换
3. **消息区域**: 显示当前聊天室的消息历史，支持滚动查看
4. **输入栏**: 用户输入消息的地方，支持多行输入

## 协议处理逻辑

### 客户端请求处理

#### 初始化和聊天列表获取
```cpp
void ChatManager::initiate() {
    ClientPacket chats_request;
    chats_request.request = ClientMessage::LIST_CHATS;
    chats_request.user_id = current_user_id;
    send_packet(server_sock, chats_request);

    ServerPacket chats_packet = recv_server_packet(server_sock);
    handle_chat_lists(chats_packet);
}
```

#### 发送消息流程
```cpp
void ChatManager::add_message(const std::string &message) {
    ClientPacket packet;
    packet.request = ClientMessage::MESSAGE;
    packet.user_id = current_user_id;
    packet.chat_id = current_chat_id;
    packet.message = message;
    packet.username = current_username;
    packet.message_id = Utils::get_uuid();

    send_packet(server_sock, packet);
    window_manager->render_new_message(Message(packet, Utils::get_iso_timestamp()));
}
```

#### 创建聊天室流程
```cpp
void ChatManager::create_chat(const std::string &chatname) {
    ClientPacket packet;
    packet.request = ClientMessage::CREATE_CHAT;
    packet.user_id = current_user_id;
    packet.chatname = chatname;
    send_packet(server_sock, packet);
}
```

#### 加入聊天室流程
```cpp
void ChatManager::join_chat(const string &chat_id) {
    ClientPacket packet;
    packet.request = ClientMessage::JOIN_CHAT;
    packet.chat_id = chat_id;
    packet.user_id = current_user_id;
    send_packet(server_sock, packet);
}
```

### 服务器响应处理

#### 消息循环处理
```cpp
void ChatManager::network_loop() {
    while (connected) {
        try {
            ServerPacket packet = recv_server_packet(server_socket);
            handle_server_response(packet);
        } catch (const std::exception& e) {
            log(LogLevel::ERROR, "Network error: " + std::string(e.what()));
            connected = false;
            break;
        }
    }
}

### 服务器响应处理

#### 消息循环处理 ([`client.cpp:153-181`](../client/client.cpp:153))
```cpp
void handle_server_receive() {
    while (true) {
        ServerPacket packet = recv_server_packet(server_fd);

        switch (packet.request) {
        case ServerMessage::NEW_MESSAGE:
            chat_manager.handle_new_message(packet);
            break;
        case ServerMessage::RETURN_CHATS:
            chat_manager.handle_chat_lists(packet);
            break;
        case ServerMessage::RETURN_MESSAGES:
            chat_manager.handle_chat_history(packet);
            break;
        case ServerMessage::JOIN_CHAT_RESPONSE:
            chat_manager.handle_new_chat(packet);
            break;
        case ServerMessage::CREATE_CHAT_RESPONSE:
            chat_manager.handle_new_chat(packet);
            break;

        default:
            break;
        }
    }
}
```

#### 聊天列表更新
```cpp
void ChatManager::handle_chat_lists(const ServerPacket &packet) {
    chat_list = packet.chats;
    window_manager->render_chats(packet.chats);
}
```

#### 消息历史更新
```cpp
void ChatManager::handle_chat_history(const ServerPacket &packet) {
    current_chat.messages = packet.message_list;
    window_manager->render_chat_history(packet.message_list);
}
```

#### 新消息处理
```cpp
void ChatManager::handle_new_message(const ServerPacket &packet) {
    if (packet.status == ServerStatus::SUCCESS) {
        // 检查message_list是否为空，避免数组越界访问
        if (packet.message_list.empty()) {
            return;
        }
        current_chat.add_message(packet.message_list[0]);
        current_chat_id = packet.chat_id;
        window_manager->render_new_message(packet.message_list[0]);
    }
}
```

#### 新聊天室处理
```cpp
void ChatManager::handle_new_chat(const ServerPacket &packet) {
    // 检查chats向量是否为空，避免数组越界访问
    if (packet.chats.empty()) {
        // 如果chats为空但从服务器返回了有效的chat信息，手动创建ChatInfo
        if (!packet.chat_id.empty() && !packet.chatname.empty()) {
            ChatInfo new_chat;
            new_chat.chat_id = packet.chat_id;
            new_chat.chatname = packet.chatname;
            new_chat.role = "member"; // 默认角色
            current_chat_id = packet.chat_id;
            chat_list.push_back(new_chat);
            window_manager->render_new_chat(new_chat);
        }
        return;
    }
    
    chat_list.push_back(packet.chats[0]);
    current_chat_id = packet.chat_id;
    window_manager->render_new_chat(packet.chats[0]);
}
```

## 窗口管理实现

### ncurses 初始化
```cpp
void WindowManager::initialize_windows() {
    // 初始化ncurses
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    start_color();
    
    // 定义颜色方案
    init_pair(1, COLOR_WHITE, COLOR_BLUE);    // 标题栏
    init_pair(2, COLOR_BLACK, COLOR_WHITE);   // 聊天列表
    init_pair(3, COLOR_WHITE, COLOR_BLACK);   // 消息区域
    init_pair(4, COLOR_GREEN, COLOR_BLACK);   // 输入栏
    
    // 获取屏幕尺寸
    getmaxyx(stdscr, main_height, main_width);
    
    // 创建子窗口
    create_sub_windows();
    refresh_windows();
}
```

### 窗口创建和布局
```cpp
void WindowManager::create_sub_windows() {
    // 聊天列表窗口 (左侧)
    chat_list_width = main_width / 4;
    chat_list_height = main_height - 3;  // 减去标题栏和输入栏
    chat_list_window = newwin(chat_list_height, chat_list_width, 1, 0);
    
    // 消息显示窗口 (右侧)
    message_width = main_width - chat_list_width;
    message_height = main_height - 3;
    message_window = newwin(message_height, message_width, 1, chat_list_width);
    
    // 输入窗口 (底部)
    input_window = newwin(1, main_width, main_height - 1, 0);
    
    // 设置窗口属性
    wbkgd(chat_list_window, COLOR_PAIR(2));
    wbkgd(message_window, COLOR_PAIR(3));
    wbkgd(input_window, COLOR_PAIR(4));
    
    // 启用滚动
    scrollok(message_window, TRUE);
}
```

### 输入处理
```cpp
void WindowManager::handle_key_input(int key) {
    static std::string input_buffer;
    static int cursor_pos = 0;
    
    switch (key) {
    case KEY_ENTER:
    case '\n':
        if (!input_buffer.empty()) {
            // 发送消息
            chat_manager->send_message(current_chat_id, input_buffer);
            input_buffer.clear();
            cursor_pos = 0;
        }
        break;
        
    case KEY_BACKSPACE:
    case 127:
        if (cursor_pos > 0) {
            input_buffer.erase(cursor_pos - 1, 1);
            cursor_pos--;
        }
        break;
        
    case KEY_LEFT:
        if (cursor_pos > 0) cursor_pos--;
        break;
        
    case KEY_RIGHT:
        if (cursor_pos < input_buffer.length()) cursor_pos++;
        break;
        
    case KEY_UP:
        // 切换到上一个聊天室
        set_current_chat(current_chat_index - 1);
        break;
        
    case KEY_DOWN:
        // 切换到下一个聊天室
        set_current_chat(current_chat_index + 1);
        break;
        
    default:
        if (isprint(key)) {
            input_buffer.insert(cursor_pos, 1, char(key));
            cursor_pos++;
        }
        break;
    }
    
    // 更新输入栏显示
    update_input_display(input_buffer, cursor_pos);
}
```

## 消息加密

### AES 加密实现
```cpp
class MessageEncryption {
private:
    std::string encryption_key;
    
public:
    MessageEncryption(const std::string& key) : encryption_key(key) {}
    
    std::string encrypt(const std::string& plaintext) {
        // 使用AES-256-CBC加密
        // 实际实现需要使用OpenSSL或类似库
        return aes_encrypt(plaintext, encryption_key);
    }
    
    std::string decrypt(const std::string& ciphertext) {
        // 使用AES-256-CBC解密
        return aes_decrypt(ciphertext, encryption_key);
    }
    
private:
    std::string aes_encrypt(const std::string& data, const std::string& key);
    std::string aes_decrypt(const std::string& data, const std::string& key);
};
```

## 当前实现状态

### 已实现功能
- ✅ 基本的窗口管理框架
- ✅ 网络通信基础结构
- ✅ 协议定义和数据包传输
- ✅ 用户注册和登录界面
- ✅ 基本的消息输入处理
- ✅ 完整的聊天管理功能
- ✅ 消息发送和接收
- ✅ 聊天室创建和加入
- ✅ 消息历史获取
- ✅ 聊天列表获取
- ✅ 消息撤回功能
- ✅ 服务器响应处理

### 待实现功能
- ⏳ 完整的UI渲染和更新
- ⏳ 消息显示和滚动
- ⏳ 聊天列表管理
- ⏳ 消息加密/解密
- ⏳ 文件传输支持
- ⏳ 表情和格式化消息
- ⏳ 通知系统
- ⏳ 配置管理

### 代码问题和建议

1. **UI渲染问题**: [`render_*`](../client/window_manager.cpp) 方法使用cout/printf而非ncurses窗口渲染
2. **UI线程安全**: 需要确保UI更新操作在主线程中执行
3. **内存管理**: 注意窗口资源的正确释放
4. **错误处理**: 需要更完善的网络错误处理和重连机制
5. **性能优化**: 大量消息时的渲染性能优化
6. **用户体验**: 添加快捷键支持和更友好的交互

## 性能优化建议

### UI渲染优化
1. **增量更新**: 只更新变化的窗口区域
2. **消息分页**: 大量消息时分页显示
3. **虚拟滚动**: 实现消息的虚拟滚动
4. **缓存机制**: 缓存渲染后的消息内容

### 网络优化
1. **消息队列**: 实现本地消息队列
2. **重连机制**: 自动重连和状态恢复
3. **心跳检测**: 定期检测连接状态
4. **压缩传输**: 对大消息进行压缩

### 内存优化
1. **对象池**: 复用消息对象
2. **智能指针**: 使用智能指针管理内存
3. **定期清理**: 清理过期的消息历史

## 扩展功能建议

1. **主题系统**: 支持多种颜色主题
2. **插件系统**: 支持第三方插件扩展
3. **多语言支持**: 国际化支持
4. **语音消息**: 支持语音录制和播放
5. **文件分享**: 支持文件传输功能
6. **搜索功能**: 消息和聊天室搜索
7. **快捷回复**: 预设快捷回复内容
8. **消息状态**: 显示消息已读/未读状态