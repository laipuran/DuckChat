# DuckChat 客户端实现

本文档描述了 DuckChat 客户端的具体实现逻辑和代码结构，基于实际的代码实现。

## 核心架构

### 主要组件
- **主客户端** ([`client.cpp`](../client/client.cpp)): 程序入口和主循环
- **窗口管理器** ([`window_manager.hpp`](../client/window_manager.hpp)): 管理用户界面和窗口显示
- **聊天管理器** ([`chat_manager.hpp`](../client/chat_manager.hpp)): 处理聊天逻辑和网络通信
- **通信协议** ([`common/protocal.hpp`](../common/protocal.hpp)): 定义数据包格式
- **网络通信** ([`common/network.hpp`](../common/network.hpp)): 处理网络传输

### 线程模型
```
主线程 (UI渲染和输入处理)
├── 网络线程 (消息收发)
├── 消息处理线程 (协议解析)
└── UI更新线程 (界面刷新)
```

## 核心类设计

### 主客户端 (client.cpp)
```cpp
int main() {
    // 初始化网络连接
    // 创建窗口管理器
    // 创建聊天管理器
    // 启动UI主循环
    return 0;
}
```

### WindowManager 类
```cpp
class WindowManager {
private:
    // ncurses 窗口句柄
    WINDOW* main_window;
    WINDOW* chat_window;
    WINDOW* input_window;
    WINDOW* status_window;
    
    // 窗口尺寸
    int main_height, main_width;
    int chat_height, chat_width;
    int input_height, input_width;
    
    // UI状态
    bool running;
    int current_chat_index;
    
public:
    WindowManager();
    ~WindowManager();
    
    // 窗口管理
    void initialize_windows();
    void resize_windows();
    void refresh_windows();
    
    // 显示功能
    void display_chat_list(const std::vector<ChatInfo>& chats);
    void display_messages(const std::vector<Message>& messages);
    void display_status(const std::string& status);
    
    // 输入处理
    std::string get_user_input();
    void handle_key_input(int key);
    
    // UI控制
    void set_current_chat(int index);
    void show_notification(const std::string& message);
};
```

### ChatManager 类
```cpp
class ChatManager {
private:
    int server_socket;
    WindowManager* window_manager;
    std::string current_user_id;
    std::string current_username;
    
    // 聊天数据
    std::vector<ChatInfo> chat_list;
    std::map<std::string, std::vector<Message>> message_history;
    
    // 线程管理
    std::thread network_thread;
    std::thread message_thread;
    std::mutex data_mutex;
    std::atomic<bool> connected;
    
public:
    ChatManager(WindowManager* wm);
    ~ChatManager();
    
    // 网络连接
    bool connect_to_server(const std::string& host, int port);
    void disconnect();
    
    // 用户操作
    bool register_user(const std::string& user_id, const std::string& username, 
                      const std::string& password);
    bool login_user(const std::string& user_id, const std::string& password);
    void logout_user();
    
    // 聊天操作
    bool create_chat(const std::string& chat_name);
    bool join_chat(const std::string& chat_id);
    bool leave_chat(const std::string& chat_id);
    bool send_message(const std::string& chat_id, const std::string& message);
    bool recall_message(const std::string& chat_id, const std::string& message_id);
    
    // 数据获取
    void refresh_chat_list();
    void refresh_messages(const std::string& chat_id);
    
    // 消息处理
    void start_message_loop();
    void handle_server_response(const ServerPacket& packet);
    
private:
    void network_loop();
    void process_incoming_messages();
    void update_ui();
};
```

## 用户界面设计

### 窗口布局
```
┌─────────────────────────────────────────────────────────────┐
│ DuckChat - 用户名                    [状态] [时间]          │ 标题栏
├─────────────┬───────────────────────────────────────────────┤
│ 聊天列表     │ 聊天消息区域                                  │
│ ✓ 聊天室1    │ [用户1] 12:30: Hello World!                  │
│ ✓ 聊天室2    │ [用户2] 12:31: Hi there!                     │
│   聊天室3    │ [用户1] 12:32: How are you?                  │
│   聊天室4    │                                               │
│   聊天室5    │                                               │
│             │                                               │
├─────────────┴───────────────────────────────────────────────┤
│ > 输入消息内容...                                          │ 输入栏
└─────────────────────────────────────────────────────────────┘
```

### 窗口功能
1. **标题栏**: 显示应用名称、当前用户、连接状态和时间
2. **聊天列表**: 显示用户参与的所有聊天室，支持选择切换
3. **消息区域**: 显示当前聊天室的消息历史，支持滚动查看
4. **输入栏**: 用户输入消息的地方，支持多行输入

## 协议处理逻辑

### 客户端请求处理

#### 用户注册流程
```cpp
bool ChatManager::register_user(const std::string& user_id, 
                               const std::string& username,
                               const std::string& password) {
    ClientPacket packet;
    packet.request = ClientMessage::REGISTER;
    packet.user_id = user_id;
    packet.username = username;
    packet.password_hash = hash_password(password);
    
    send_packet(server_socket, packet);
    
    // 等待服务器响应
    ServerPacket response = recv_server_packet(server_socket);
    
    return response.status == ServerStatus::SUCCESS;
}
```

#### 用户登录流程
```cpp
bool ChatManager::login_user(const std::string& user_id, 
                            const std::string& password) {
    ClientPacket packet;
    packet.request = ClientMessage::LOGIN;
    packet.user_id = user_id;
    packet.password_hash = hash_password(password);
    
    send_packet(server_socket, packet);
    
    // 等待服务器响应
    ServerPacket response = recv_server_packet(server_socket);
    
    if (response.status == ServerStatus::SUCCESS) {
        current_user_id = user_id;
        current_username = response.username;
        connected = true;
        
        // 启动消息处理线程
        start_message_loop();
        return true;
    }
    
    return false;
}
```

#### 发送消息流程
```cpp
bool ChatManager::send_message(const std::string& chat_id, 
                              const std::string& message) {
    if (!connected) {
        window_manager->show_notification("未连接到服务器");
        return false;
    }
    
    ClientPacket packet;
    packet.request = ClientMessage::MESSAGE;
    packet.user_id = current_user_id;
    packet.chat_id = chat_id;
    packet.message_id = generate_message_id();
    packet.message = encrypt_message(message);  // AES加密
    
    send_packet(server_socket, packet);
    
    // 本地显示发送的消息
    Message local_msg;
    local_msg.message_id = packet.message_id;
    local_msg.user_id = current_user_id;
    local_msg.content = message;
    local_msg.timestamp = get_current_timestamp();
    
    {
        std::lock_guard<std::mutex> lock(data_mutex);
        message_history[chat_id].push_back(local_msg);
    }
    
    update_ui();
    return true;
}
```

### 服务器响应处理

#### 消息循环处理
```cpp
void ChatManager::network_loop() {
    while (connected) {
        try {
            ServerPacket packet = recv_server_packet(server_socket);
            handle_server_response(packet);
        } catch (const std::exception& e) {
            log(LogLevel::ERROR, "Network error: " + std::string(e.what()));
            connected = false;
            break;
        }
    }
}

void ChatManager::handle_server_response(const ServerPacket& packet) {
    switch (packet.request) {
    case ServerMessage::LOGIN_RESPONSE:
        handle_login_response(packet);
        break;
        
    case ServerMessage::REGISTER_RESPONSE:
        handle_register_response(packet);
        break;
        
    case ServerMessage::RETURN_CHATS:
        handle_chat_list_response(packet);
        break;
        
    case ServerMessage::RETURN_MESSAGES:
        handle_messages_response(packet);
        break;
        
    default:
        break;
    }
}
```

#### 聊天列表更新
```cpp
void ChatManager::handle_chat_list_response(const ServerPacket& packet) {
    // 解析聊天列表数据
    std::vector<ChatInfo> new_chats;
    
    // 从packet中解析聊天信息
    // (需要根据实际协议格式实现)
    
    {
        std::lock_guard<std::mutex> lock(data_mutex);
        chat_list = new_chats;
    }
    
    // 更新UI显示
    window_manager->display_chat_list(chat_list);
}
```

#### 消息历史更新
```cpp
void ChatManager::handle_messages_response(const ServerPacket& packet) {
    std::string chat_id = packet.chat_id;
    std::vector<Message> new_messages;
    
    // 从packet.message_list中解析消息
    for (const auto& msg_packet : packet.message_list) {
        Message msg;
        msg.message_id = msg_packet.message_id;
        msg.user_id = msg_packet.user_id;
        msg.content = decrypt_message(msg_packet.message);  // AES解密
        msg.timestamp = msg_packet.timestamp;  // 需要在协议中添加
        
        new_messages.push_back(msg);
    }
    
    {
        std::lock_guard<std::mutex> lock(data_mutex);
        message_history[chat_id] = new_messages;
    }
    
    // 如果是当前聊天，更新显示
    if (window_manager->get_current_chat_id() == chat_id) {
        window_manager->display_messages(new_messages);
    }
}
```

## 窗口管理实现

### ncurses 初始化
```cpp
void WindowManager::initialize_windows() {
    // 初始化ncurses
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    start_color();
    
    // 定义颜色方案
    init_pair(1, COLOR_WHITE, COLOR_BLUE);    // 标题栏
    init_pair(2, COLOR_BLACK, COLOR_WHITE);   // 聊天列表
    init_pair(3, COLOR_WHITE, COLOR_BLACK);   // 消息区域
    init_pair(4, COLOR_GREEN, COLOR_BLACK);   // 输入栏
    
    // 获取屏幕尺寸
    getmaxyx(stdscr, main_height, main_width);
    
    // 创建子窗口
    create_sub_windows();
    refresh_windows();
}
```

### 窗口创建和布局
```cpp
void WindowManager::create_sub_windows() {
    // 聊天列表窗口 (左侧)
    chat_list_width = main_width / 4;
    chat_list_height = main_height - 3;  // 减去标题栏和输入栏
    chat_list_window = newwin(chat_list_height, chat_list_width, 1, 0);
    
    // 消息显示窗口 (右侧)
    message_width = main_width - chat_list_width;
    message_height = main_height - 3;
    message_window = newwin(message_height, message_width, 1, chat_list_width);
    
    // 输入窗口 (底部)
    input_window = newwin(1, main_width, main_height - 1, 0);
    
    // 设置窗口属性
    wbkgd(chat_list_window, COLOR_PAIR(2));
    wbkgd(message_window, COLOR_PAIR(3));
    wbkgd(input_window, COLOR_PAIR(4));
    
    // 启用滚动
    scrollok(message_window, TRUE);
}
```

### 输入处理
```cpp
void WindowManager::handle_key_input(int key) {
    static std::string input_buffer;
    static int cursor_pos = 0;
    
    switch (key) {
    case KEY_ENTER:
    case '\n':
        if (!input_buffer.empty()) {
            // 发送消息
            chat_manager->send_message(current_chat_id, input_buffer);
            input_buffer.clear();
            cursor_pos = 0;
        }
        break;
        
    case KEY_BACKSPACE:
    case 127:
        if (cursor_pos > 0) {
            input_buffer.erase(cursor_pos - 1, 1);
            cursor_pos--;
        }
        break;
        
    case KEY_LEFT:
        if (cursor_pos > 0) cursor_pos--;
        break;
        
    case KEY_RIGHT:
        if (cursor_pos < input_buffer.length()) cursor_pos++;
        break;
        
    case KEY_UP:
        // 切换到上一个聊天室
        set_current_chat(current_chat_index - 1);
        break;
        
    case KEY_DOWN:
        // 切换到下一个聊天室
        set_current_chat(current_chat_index + 1);
        break;
        
    default:
        if (isprint(key)) {
            input_buffer.insert(cursor_pos, 1, char(key));
            cursor_pos++;
        }
        break;
    }
    
    // 更新输入栏显示
    update_input_display(input_buffer, cursor_pos);
}
```

## 消息加密

### AES 加密实现
```cpp
class MessageEncryption {
private:
    std::string encryption_key;
    
public:
    MessageEncryption(const std::string& key) : encryption_key(key) {}
    
    std::string encrypt(const std::string& plaintext) {
        // 使用AES-256-CBC加密
        // 实际实现需要使用OpenSSL或类似库
        return aes_encrypt(plaintext, encryption_key);
    }
    
    std::string decrypt(const std::string& ciphertext) {
        // 使用AES-256-CBC解密
        return aes_decrypt(ciphertext, encryption_key);
    }
    
private:
    std::string aes_encrypt(const std::string& data, const std::string& key);
    std::string aes_decrypt(const std::string& data, const std::string& key);
};
```

## 当前实现状态

### 已实现功能
- ✅ 基本的窗口管理框架
- ✅ 网络通信基础结构
- ✅ 协议定义和数据包传输
- ✅ 用户注册和登录界面
- ✅ 基本的消息输入处理

### 待实现功能
- ⏳ 完整的UI渲染和更新
- ⏳ 消息显示和滚动
- ⏳ 聊天列表管理
- ⏳ 消息加密/解密
- ⏳ 文件传输支持
- ⏳ 表情和格式化消息
- ⏳ 通知系统
- ⏳ 配置管理

### 代码问题和建议

1. **UI线程安全**: 需要确保UI更新操作在主线程中执行
2. **内存管理**: 注意窗口资源的正确释放
3. **错误处理**: 需要更完善的网络错误处理和重连机制
4. **性能优化**: 大量消息时的渲染性能优化
5. **用户体验**: 添加快捷键支持和更友好的交互

## 性能优化建议

### UI渲染优化
1. **增量更新**: 只更新变化的窗口区域
2. **消息分页**: 大量消息时分页显示
3. **虚拟滚动**: 实现消息的虚拟滚动
4. **缓存机制**: 缓存渲染后的消息内容

### 网络优化
1. **消息队列**: 实现本地消息队列
2. **重连机制**: 自动重连和状态恢复
3. **心跳检测**: 定期检测连接状态
4. **压缩传输**: 对大消息进行压缩

### 内存优化
1. **对象池**: 复用消息对象
2. **智能指针**: 使用智能指针管理内存
3. **定期清理**: 清理过期的消息历史

## 扩展功能建议

1. **主题系统**: 支持多种颜色主题
2. **插件系统**: 支持第三方插件扩展
3. **多语言支持**: 国际化支持
4. **语音消息**: 支持语音录制和播放
5. **文件分享**: 支持文件传输功能
6. **搜索功能**: 消息和聊天室搜索
7. **快捷回复**: 预设快捷回复内容
8. **消息状态**: 显示消息已读/未读状态