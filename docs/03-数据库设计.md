# DuckChat 数据库设计

本文档描述了 DuckChat 系统的 SQLite 数据库设计，支持用户管理、聊天室管理、消息存储和撤回功能。

## 数据库概述

- **数据库类型**: SQLite
- **字符编码**: UTF-8
- **时区**: UTC
- **设计原则**: 规范化设计，避免数据冗余，保证数据一致性

## 表结构设计

### 1. users 表 - 用户信息

存储用户基本信息和认证数据。

```sql
CREATE TABLE users (
    user_id TEXT PRIMARY KEY,           -- 用户唯一标识
    username TEXT NOT NULL,              -- 用户名
    password_hash TEXT NOT NULL          -- 密码哈希值
);
```

**字段说明:**
- `user_id`: 系统生成的唯一用户标识符
- `username`: 用户显示名称，必须唯一
- `password_hash`: 使用 PBKDF2 算法生成的密码哈希
- `salt`: 密码加密使用的随机盐值
- `status`: 用户当前在线状态

### 2. chats 表 - 聊天室信息

存储聊天室基本信息。

```sql
CREATE TABLE chats (
    chat_id TEXT PRIMARY KEY,           -- 聊天室唯一标识
    chatname TEXT NOT NULL,            -- 聊天室名称
    creator_id TEXT NOT NULL,          -- 创建者ID
    FOREIGN KEY (creator_id) REFERENCES users(user_id)
);
```

**字段说明:**
- `chat_id`: 系统生成的唯一聊天室标识符
- `chat_name`: 聊天室显示名称
- `chat_type`: 聊天类型，支持群聊和私聊
- `member_count`: 实时统计的成员数量

### 3. chat_members 表 - 聊天室成员关系

存储用户与聊天室的成员关系和权限信息。

```sql
CREATE TABLE chat_members (
    chat_id TEXT,                      -- 聊天室ID
    user_id TEXT NOT NULL,              -- 用户ID
    role TEXT DEFAULT 'member',         -- 角色：member/admin/owner
    FOREIGN KEY (chat_id) REFERENCES chats(chat_id),
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    UNIQUE(chat_id, user_id)            -- 确保同一用户不会重复加入同一聊天室
);
```

**字段说明:**
- `role`: 用户在聊天室中的角色权限
- `last_read_message_id`: 用于标记已读状态
- `is_muted`: 用户是否对该聊天室静音

### 4. messages 表 - 消息记录

存储所有聊天消息，支持消息撤回功能。

```sql
CREATE TABLE messages (
    message_id TEXT PRIMARY KEY,        -- 消息唯一标识
    chat_id TEXT NOT NULL,              -- 所属聊天室
    sender_id TEXT NOT NULL,            -- 发送者ID
    content TEXT NOT NULL,              -- 消息内容
    sent_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chat_id) REFERENCES chats(chat_id),
    FOREIGN KEY (sender_id) REFERENCES users(user_id)
);
```

**字段说明:**
- `content`: 存储客户端加密后的消息内容
- `message_type`: 支持扩展多种消息类型
- `is_recalled`: 标记消息是否被撤回
- `recalled_by`: 记录执行撤回操作的用户

### 5. message_reads 表 - 消息已读状态

跟踪用户对消息的阅读状态（可选功能）。

```sql
CREATE TABLE message_reads (
    message_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    read_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (message_id, user_id),
    FOREIGN KEY (message_id) REFERENCES messages(message_id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);
```

## 索引设计

为了优化查询性能，创建以下索引：

```sql
-- 基础索引（当前实现中未创建，建议添加）
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_messages_chat_time ON messages(chat_id, sent_at DESC);
CREATE INDEX idx_chat_members_user ON chat_members(user_id);
CREATE INDEX idx_chat_members_chat ON chat_members(chat_id);
```

## 数据库操作示例

### 用户操作

**用户注册:**
```sql
INSERT INTO users (user_id, username, password_hash)
VALUES (?, ?, ?);
```

**用户登录验证:**
```sql
SELECT user_id, username, password_hash, salt 
FROM users 
WHERE username = ?;
```

**更新用户状态:**
```sql
UPDATE users 
SET status = ?, last_login = CURRENT_TIMESTAMP 
WHERE user_id = ?;
```

### 聊天室操作

**创建聊天室:**
```sql
BEGIN TRANSACTION;
INSERT INTO chats (chat_id, chat_name, creator_id) VALUES (?, ?, ?);
INSERT INTO chat_members (chat_id, user_id, role) VALUES (?, ?, 'owner');
COMMIT;
```

**加入聊天室:**
```sql
INSERT INTO chat_members (chat_id, user_id, role) 
VALUES (?, ?, 'member');

UPDATE chats 
SET member_count = member_count + 1 
WHERE chat_id = ?;
```

**获取用户聊天列表:**
```sql
SELECT c.chat_id, c.chat_name, c.member_count, c.last_message_time,
       cm.role, cm.last_read_message_id
FROM chats c
JOIN chat_members cm ON c.chat_id = cm.chat_id
WHERE cm.user_id = ?
ORDER BY c.last_message_time DESC;
```

### 消息操作

**发送消息:**
```sql
INSERT INTO messages (message_id, chat_id, sender_id, content, message_type)
VALUES (?, ?, ?, ?, ?);

UPDATE chats 
SET last_message_time = CURRENT_TIMESTAMP 
WHERE chat_id = ?;
```

**撤回消息:**
```sql
UPDATE messages 
SET is_recalled = TRUE, 
    recalled_at = CURRENT_TIMESTAMP,
    recalled_by = ?
WHERE message_id = ? AND sender_id = ?;
```

**获取聊天记录:**
```sql
SELECT m.message_id, m.sender_id, u.username, 
       m.content, m.sent_at, m.is_recalled, m.recalled_at,
       m.message_type, m.edit_count
FROM messages m
JOIN users u ON m.sender_id = u.user_id
WHERE m.chat_id = ? 
ORDER BY m.sent_at DESC
LIMIT ? OFFSET ?;
```

**更新已读状态:**
```sql
UPDATE chat_members 
SET last_read_message_id = ? 
WHERE chat_id = ? AND user_id = ?;
```

## 数据完整性约束

### 外键约束
- 删除用户时，自动删除其成员关系和消息
- 删除聊天室时，自动删除相关成员关系和消息
- 删除消息时，自动删除相关已读状态

### 业务规则约束
- 用户名必须唯一
- 同一用户不能重复加入同一聊天室
- 只有消息发送者可以撤回消息
- 聊天室创建者自动成为所有者

## 性能优化建议

1. **定期清理**: 定期清理已撤回的旧消息
2. **分页查询**: 历史消息查询使用 LIMIT 和 OFFSET
3. **缓存策略**: 热点聊天室信息可以缓存
4. **索引维护**: 定期分析查询性能，优化索引

## 备份和恢复

### 备份策略
```sql
-- 完整备份
.backup duckchat_backup.db

-- 增量备份（导出SQL）
.output backup.sql
.dump
```

### 恢复策略
```sql
-- 从备份文件恢复
.restore duckchat_backup.db

-- 从SQL文件恢复
.read backup.sql
```

## 安全考虑

1. **密码安全**: 使用 PBKDF2 算法加盐哈希存储密码
2. **数据加密**: 敏感消息内容在数据库中加密存储
3. **SQL注入防护**: 使用参数化查询
4. **访问控制**: 通过应用层控制数据访问权限